# Struct&Class&Enum

안녕하세요!! :D
오늘은 클래스와 구조체에 관해 공부해보겠습니다1!!! 오늘두 화이팅!

먼저, 관련 용어부터 같이 이야기해볼까요??


구조체와 클래스는 하나의 큰 코드 블록
1. 변수나 상수를 넣어 값을 저장할 수 있음
2. 함수를 넣어서 기능을 정의할 수 있음
--> 값을 저장할 수는 없지만 특정 기능을 실행할 수 있는 함수와, 값을 저장할 수 있지만 혼자서 특정 기능을 실행할 수는 없는 변수 상수의 특성을 모두 모아 놓았다고 이해하면 편리합니다.

독자적인 프로세스 수행 능력 덕분에 매우 강력한 사용성을 지니는 이들 객체는 언어적으로 유연성을 가질 수 있게 해주는 근간을 이룹니다.
유연성이란? 코드를 떼어서 다른 곳으로 옮기거나 새로운 코드를 추가하기가 쉽다는 뜻으로, 의존성의 반대 개념입니다.

구조체와 클래스 내부에서 정의되면
상수와 변수 -> 프로퍼티(Property)
함수 -> 메소드(Method)

프로퍼티 + 메소드 = 구조체나 클래스의 멤버 
--> 프로퍼티와 메소드가 구조체나 클래스를 이루는 핵심 요소이기때문에

구조체와 클래스의 공통점
- 프로퍼티 : 변수나 상수를 사용하여 값을 저장하는 프로퍼티를 정의할 수 있다.
- 메소드 : 함수를 사용하여 기능을 제공하는 메소드를 정의할 수 있다.
- 서브스크립트 : 속성 값에 접근할 수 있는 방법을 제공하는 서브 스크립트를 정의할 수 있다.
- 초기화 블록 : 객체를 원하는 초기 상태로 설정해주는 초기화 블록을 정의할 수 있다.
- 확장 : 객체에 함수적 기능을 추가하는 확장(extends) 구문을 사용할 수 있다.
- 프로토콜 : 특정 형식의 함수적 표준을 제공하기 위한 프로토콜을 구현할 수 있다.


클래스만 가능한 기능
- 상속 : 클래스의 특성을 다른 클래스에게 물려줄 수 있다.
- 타입 캐스팅 : 실행 시 컴파일러가 클래스 인스턴스의 타입을 미리 파악하고 검사할 수 있다.
- 소명화 구문 : 인스턴스가 소멸되기 직전에 처리해야 할 구문을 미리 등록해 놓을 수 있다.
- 참조에 의한 전달 : 클래스 인스턴스가 전달될 때에는 참조 형식으로 제공되며, 이때 참조가 가능한 개수는 제약이 없다.


구조체, 클래스, 열거형, 프로토콜 등의 객체에서의 이름 표기법
카멜(Camel) 표기법 : 대문자와 소문자들이 배열된 모습이 마치 낙타 등의 혹을 연상시킨다고 하여 부르는 이름

1. 구조체와 클래스 이름의 첫 글자는 대문자로, 나머지 글자는 소문자로 작성합니다.
2. 2개 이상의 복합 단어는 단어별로 끊어 첫 글자는 대문자로, 나머지는 소문자로 작성한다.
3. 이미 축약된 약어는 모두 대문자로 작성 가능하다(ex. JSON, NS, HTTP 등)
4. 프로퍼티나 메소드를 선언할 때는 소문자로 시작한다.
5. 언더바로 단어를 연결하는 방식은 지양한다.

프로퍼티는 오직 인스턴스를 통해서만 접근할 수 있다.
인스턴스가 생성되지 않은 상태에서는 프로퍼티도 존재하지 않는 것
구조체나 클래스의 이름을 통해서는 프로퍼티에 접근할 수 없음
인스턴스 생성 후 점(Dot syntax)을 이용하여 인스턴스의 하위 객체에 접근할 수 있습니다.

<인스턴스 이름>.<프로퍼티 이름>
<인스턴스 이름>.<프로퍼티 이름>.<서브 프로퍼티 이름>






1. Class


 프로퍼티(클래스 안의 변수)와 메소드(클래스 안의 함수)를 가질 수 있는 컨테이너 타입을 정의하기위한 용도
 일반적으로 단일 상속이 가능하지만, 프로토콜을 사용하면 다중 상속도 가능
 참조타입 (=reference type) (call by reference)
형 변환(Type Casting)과 관련된 기능과 파괴자(Deinitializer)등의 기능을 가질 수 있다.
iOS 프레임 워크의 대부분의 큰 뼈대는 모두 클래스로 구성

속성 (property) : 클래스에서 제공되는 변수
메소드 (method) : 클래스에서 제공되는 함수

참조 타입이 뭐에요?

참조 타입이란, 데이터의 크기가 크고 가변적이여서 동적으로 관리 되는 메모리의 힙에 생성되는 것을 말 합니다.

선언 : 선언에 의해 참조만 생성될 뿐이지 데이터를 저장할 수 있는 실제 메모리가 할당되는 것은 아니므로 선언 즉시 사용할 수 없으며, 반드시 new 연산자로 메모리를 할당 받아 초기화 해야 합니다.
종료 : 더 이상 참조하는 변수가 없을 때 가비지 컬렉터에 의해 파괴 됩니다.
데이터 : 참조 타입끼리의 대입은 힙에 할당된 데이터를 참조하는 참조자가 하나 더 늘어날 뿐 별도의 메모리가 추가로 할당되는 것은 아닙니다. 그래서 둘 중 하나를 변경하면 상대 쪽도 같이 변경 됩니다.


클래스에 대해 이론적으로 보았으니, 정의와 구현을 해볼까요?
1.1. 클래스 정의 및 구현


아래는 정의 방식입니다.

class 클래스명 {
 ... }


이제 구현해 볼까요? Exm이라는 클래스를 만들어 보았습니다!

class Exm { 
    var name = "Sojin";
    
    func say(){ 
        print("Hello, " + name + "!"); 
        
    } 
  }


위 클래스에는 name이라는 속성과 say라는 메소드가 있습니다. name 과 say 모두 기능이겠죠?
say 메소드 안에 name 속성이 사용되고 있는 것 처럼 클래스에 있는 메소드에 내부는 그 클래스에 있는 속성과 메소드를 그대로 사용할 수 있도록 되어있습니다.

클래스 밖에서 사용하기 위해서 인스턴스를 생성해 볼까요?
인스턴스에 대해서 모르겠는 분은 OOP와 POP 포스팅을 참고해주세요!

(2) 인스턴스 생성

var/let 변수명 : 클래스명 = 클래스명();


(3) 실행해보기

인스턴스를 생성했으니, 한번 활용해서 실행해봅시다!
class Exm {
    var name = "Sojin"
    
    func say(){
        print("Hello, " + name + "!")
    }
}

var obj:Exm = Exm(); // 인스턴스 생성

obj.say(); // Hello, Sojin!

obj.name = "Hanako"; // Sojin -> Hanako

obj.say(); // Hello, Hanako


코드를 보니, 클래스 내부에 생성되어있는 객체(변수) 값을 변경 할 수도있네요?


이제 클래스의 큰 특징인 상속을 해보겠습니다!

1.2 상속하기

먼저 코드를 보기 전에 상속 코드는 어떻게 작성하는 걸까요?
class 자식 클래스명 : 부모 클래스명 {
...
}
오른쪽에 : 부모클래스명만 추가 되었죠?! 어렵지 않아요!
위와 같은 부모 클래스를 상속 받아 새로운 자식 클래스를 만드는 과정을 서브 클래싱(Subclassing)이라고 합니다:-)

이제 코드 예시로 이해해볼까요? 

Hello 클래스가 Helo 클래스를 상속 받고있는 코드 입니다.
class Helo {
    var name:String = "Sojin";
    func say(){
        print("Hello, " + name + "!");
        
    }
    
}

class Hello:Helo {
    var name2:String = "YAMADA";
    func say2(){
        print("Hi," + name + "-" + name2 + "!");
        
    }
    
}
var obj:Hello = Hello();

obj.say();
obj.name = "Sojin";
obj.name2 = "TANAKA";
obj.say2();


위 코드에서는 Hello 클래스 인스턴스만 생성했는데 Helo클래스의 함수와 객체를 선언해서 문제 없이 사용하고 있는 것을 볼 수 있습니다.

이유는 당연히 상속을 사용했기 때문이겠지요? Hello 클래스(자식 클래스) 가 Helo 클래스(부모 클래스)를 상속 받았기 때문에 부모 클래스인 Helo의 객체와 함수등을 모두 가져다가 사용할 수 있는 것입니다!
2. Struct

C 언어 구조체 용도와 비슷하지만, 추가로 멤버 변수(프로퍼티), 함수(메소드) 정의 가능
상속이 불가능
확장(extention) 등 기능 사용 가능
값 타입 (= Value Type)
Swift의 대부분의 큰 뼈대는 모두 구조체로 구성
값 타입이 뭐에요?

값 타입이란, 데이터의 크기가 고정적이기 때문에 메모리 스택에 생성되는 것을 말 합니다.

선언 : 선언만 하면 스택에 즉시 생성되므로 선언 직후부터 데이터를 저장하는 용도로 사용할 수 있습니다.
종료 : 더 이상 참조하는 변수가 없을 때 가비지 컬렉터에 의해 파괴됩니다.
데이터 : 복사에 의해 완전한 별개의 사본이 생성 되며 복사 후 사본과 원본은 별개의 변수 입니다. 즉, 완전히 다른 두 개의 변수가 생성되는 것을 말 합니다.
1.1 구조체 정의 및 구현

struct 선언 후 이름만 선언하면되는 쉬운 코드니 어려움은 없죠?
struct 구조체 이름 {
 ...
}

그냥 정의 부분만 보면 이해가 어려우니 구현 부분도 함께 보도록 하겠습니다!

struct Student {

    var name : String = "unknown"
    var `class`: String = "Swift"
    
    static func selfIntroduce() {
        print("학생타입입니다")
    }
    
    func selfIntroduce() {
        print("저는 \(self.class)반 \(name)입니다.")
    }
}

Student 구조체를 만들고 안에 객체와 함수들을 선언하였습니다.

근데 코드를 보면 변수명이 `class`인 부분이 눈에 띄죠??? 먼저 선언한 변수 name과 달리 ``로 묶여있는데 왜 일까요?
스위프트에서는 예약어나 키워드로 등록되어 있는 단어는 변수나 상수명에 사용할 수 없습니다. class는 저희가 클래스를 정의할때 사용하는 키워드죠???? 그럼 변수명으로 사용이 불가능합니다..
그치만! 아래 설명과 같이 사용하면 예약어나 키워드를 변수명으로 사용할 수 있습니다.
Class, Enum 등으로 예약어를 대소문자를 바꾸거나 ``로 묶으면 변수 명으로도 사용가능하죠! (근데 되도록이면 예약어나 키워드는 변수명으로 사용하지 않는게 좋아요)

인스턴스를 생성하여 구조체를 활용해볼까요?

(1) 인스턴스 생성

인스턴스 생성하는 코드 입니다.
let/var 변수명 = 구조체()

위에서 구현한 구조체의 인스턴스를 생성하고 활용해본 코드 입니다!
struct Student {
    var name : String = "unknown"
    var `class`: String = "Swift"
    
    static func selfIntroduce() {
        print("학생타입입니다")
    }
    
    func selfIntroduce() {
        print("저는 \(self.class)반 \(name)입니다.")
    }
}


Student.selfIntroduce() //학생 타입 입니다.

var yegom: Student = Student()
yegom.name = "yegom"
yegom.class = "스위프트"
yegom.selfIntroduce() //저는 스위프트반 yegom입니다.


let jina:Student = Student()

//불변 인스턴스이므로 프로퍼티 값 변경 불가
//컴파일 오류 발생
//jin.name = "jina"
jina.selfIntroduce()//저는 Swift반 unknown입니다.
yegom 이름으로 Student 구조체를 선언하였습니다.

`class` 객체는 인스턴스를 이용하여 불러올때 ``없이 class라고만 선언하는 것을 볼 수 있습니다.
아래 let으로 선언한 jina 인스턴스는 당연히 불변이니까 값을 바꾸려고 하면 오류가 발생하겠죠?


다른 예시 코드도 함께볼까요?

struct MyData {
    var age:Int
    var name:String
    
    func getData() ->String {
        return "[\(name)(\(age))]"
        
    }
    
}

var data = MyData(age: 99, name: "Taro")
var data2 = data
data2.name = "Sojin"
data2.age = 24
print(data.getData()) // Taro(99)
print(data2.getData()) // Sojin(24)


위의 코드의 data 처럼 직접 변수 값들을 넣어주면서 인스턴스를 생성하는 것도 가능합니다.

구조체는 내부에서 데이터를 수정할때 꼭 사용해야하는 단어가 있는데요.
바로 Mutating func입니다. 아래 설명을 같이 볼까요?
1.2 Mutating function

Mutating function이란 구조체의 매서드가 구조체 내부에서 데이터를 수정할 때 선언하는 키워드입니다.

아래 코드를 보면서 이해해봅시다.
struct Point {
var x = 0 
var y = 0 

// 컴파일 에러남.
func moveTo(x: Int, y: Int) {
    self.x = x  
    self.y = y  
  }

// 정상 실행
mutating func moveTo2(x: Int, y: Int) {
    self.x = x  
    self.y = y  
  }
}
변수 x,y를 0으로 선언을 하였고, 그 값을 변경하려 합니다.
mutating을 선언하지 않고 내부 변수 값을 변경하면 위와 같이 컴파일 에러가 나게되니깐 꼭 붙여주세요!

음.. 구조체를 그럼 언제 사용해야하나요?


swift 언어 가이드에서 친절하게 아래 조건 중에 한가지 또는 그 이상 해당하는 경우에는 구조체를 사용하라고 기준을 제시해 주었습니다.

서로 연관된 몇 개의 기본 데이터 타입들을 캡슐화하여 묶는 것이 목적일 때
캡슐화된 데이터에 상속이 필요하지 않을 때
캡슐화된 데이터를 전달하거나 할당하는 과정에서 참조 방식보다는 값이 복사되는 것이 합리적일 때
캡슐화된 원본 데이터를 보존해야 할 때

저희 클래스와 구조체를 비교도 해볼까요?

채택과 상속?

클래스 상속 : 상속받을 클래스의 모든 기능을 물려 받는 기능
프로토콜 채택 : 내가 이제 이 프로토콜을 준수하겠어! 라는 뜻

클래스와 구조체의 공통점

서로 다른 타입(자료형)들을 하나로 묶을 수 있습니다.
이러한 묶은 자료형들을 새로운 타입처럼 사용 가능합니다.
클래스/ 구조체 안에서 함수/프로퍼티 정의가 가능합니다.
extension이 가능합니다.

클래스와 구조체의 차이점

구조체는 value type, 클래스는 reference type 입니다.
구조체는 상속이 불가능합니다.
구조체에서는 AnyObject로 타입캐스팅이 불가능합니다.
구조체는 생성자를 구현하지 않을 시 기본 initializer를 사용할 수 있습니다.
클래스는 reference counting으로 메모리 관리가 가능합니다.
Enum

 상속 불가
 값 타입 (값이 없을 수도 있음. 즉 이름 그 자체 만으로 고유한 의미를 나타낼 수 있음)
 유사한 종류의 여러 값을 유의미한 이름으로 한 곳에 모아 정의한 것 예) 요일, 상태값, 월(Month)
 열거형 자체가 하나의 데이터 타입
 열거형의 case 하나하나 전부 하나의 유의미한 값으로 취급
열거형의 간단한 예제를 보겠습니다.
enum Janken {
    case Choki
    case Goo
    case Paa
    
}
enum 가위바위보 : String {
    case Choki = "가위"
    case Goo = "바위"
    case Paa = "보"
    
}

var me = Janken.Goo
var you = 가위바위보.Goo
print(me) // Goo
print(you.rawValue) // 바위
열거형 안에 선언한 case를 아래 코드처럼 활용할 수 있네요!!


클래스, 구조체, 열거형에 대해서 살펴보았는데요. 설명을 잘 했나 모르겠네요.. 
마지막으로 오늘 배운 클래스, 구조체, 열거형을 간단하게 정리한 표를 보면서 마무리 하겠습니다! 오늘도 좋은 하루 보내세용 :-)


Class    Struct    Enum
Type    Reference    Value    Vlaue
Subclassing    O    X    X
Extension    O    O    O



